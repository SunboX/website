---
layout:          default
tab:             docs
title:           Cross compiling C/C++ - JanOS
---
<div class="yolo section article">
  <div class="story left">
    <h1>Cross compiling</h1>
    <p>
      On embedded devices there are scenario's that you do not want to execute
      in JavaScript, like video encoding, or other CPU-limited tasks.
      This article will show you how to cross compile a simple C++ application
      and how to call it from JanOS.
      For a more complex application with dependencies, see our blog post
      about compiling WebP.
    </p>
    <p>
      <a target="_blank" class="button" href="http://ee.telenor.io/gonzo/webp/2015/01/20/webp.html">
        Compiling WebP for JanOS
      </a>
    </p>
  </div>
  <div class="cover-image cross-compile" title="Cross compiled C++ application called from JavaScript"></div>
</div>

<div class="section secondary">
  <h3>A simple C++ application</h3>
  <p>
    Here is the simple 'Hello world' application that we're going to cross-compile.
    Save it somewhere on your hard drive and name it 'hello.cpp'.
  </p>
  <pre><code class="language-cpp">
#include &lt;iostream&gt;

int main()
{
    std::cout << "Hello JanOS!";
    return 0;
}
</code></pre>
  <p>
    We can compile and run this with gcc via <span class="code">g++ hello.cpp -o hello && ./hello</span>.
    Now the binary that was generated by g++ won't run on JanOS, as it's compiled
    for your current architecture. Most phones (at least the one's we support)
    use the ARMv7 architecture.
    So to run this file we need to use a cross-compiler.
  </p>
</div>

<div class="section secondary">
  <h3>Cross compiling using Native Toolchain</h3>
  <p>
    The Android NDK comes with tools to create a 'toolchain', which
    sets up gcc to cross compile.
    First, <a href="https://developer.android.com/tools/sdk/ndk/index.html">install the NDK</a>
    for your platform.
    Open a terminal and navigate to the directory where the NDK is extracted,
    and make a toolchain for arm via:
  </p>
  <pre><code class="language-bash">
$ build/tools/make-standalone-toolchain.sh --arch=arm --install-dir=/tmp/ndk-arm
</code></pre>
  <p>
    Now go back to the folder where you created hello.cpp,
    and you can now use the newly created gcc to compile it instead.
    Afterwards push it to your device, and verify that it worked.
  </p>
  <pre><code class="language-bash">
$ /tmp/ndk-arm/bin/arm-linux-androideabi-g++ hello.cpp -o hello

# now remount so we can write to the /system partition
$ adb remount
# push to a directory, /system/bin is the bin directory on GeeksPhone
# might be different on other devices
$ adb push hello /system/bin/hello

# test whether it worked
$ adb shell hello</code></pre>
</div>

<div class="section secondary">
  <h3>Cross compiling with Android.mk</h3>
  <p>
    It's also possible to use the NDK build system to cross compile for you.
    It's similar to a normal Makefile, but targeted at Android systems.
    You can f.e. specify which libraries to link.
    If you encounter a project that already has an Android port, it's likely
    that it will already have an Android.mk file.
  </p>
  <p>
    To get started, first create a new directory called jni/.
    Then move hello.cpp into this folder.
    Then (in the same folder) create two new files.
  </p>
  <h4>jni/Application.mk</h4>
  <pre><code class="language-clike">
APP_STL := stlport_static</code></pre>
  <h4>jni/Android.mk</h4>
  <pre><code class="language-clike">
LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE       := hello
LOCAL_MODULE_CLASS := EXECUTABLES
LOCAL_SRC_FILES    := hello.cpp
include $(BUILD_EXECUTABLE)</code></pre>
  <p>
    Now go back to the folder <em>above</em> /jni, and run:
  </p>
  <pre><code class="language-bash">
$ ndk-build
[armeabi] Compile++ thumb: hello <= hello.cpp
[armeabi] Executable     : hello
[armeabi] Install        : hello => libs/armeabi/hello
</code></pre>
  <p>
    You can now push this executable to the device, same way as above.
  </p>
</div>
<div class="section secondary">
  <h3>Calling the binary from JanOS</h3>
  <p>
    Now to call the binary from JavaScript code we use the
    <a href="/api-reference/exec.html">mozOs.exec</a> API.
    Easiest to test is to attach the
    <a href="/articles/first-app.html#debugger">debugger</a>,
    and in the console type:
  </p>
  <pre><code class="language-javascript">
navigator.mozOs.exec('hello')
  .then(res => console.log(res.exitCode, res.stdout))
  .catch(err => console.error('Failure', err));

// returns 0 "Hello JanOS!"</code></pre>
</div>